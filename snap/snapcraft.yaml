# A template snapcraft.yaml
# For a full specification of the snapcraft.yaml, please see:
# https://snapcraft.io/docs/snapcraft-yaml-reference

# Do not feel obligated to perfectly adhere to this style, but strive to include
# as much metadata as possible.

# The name should be generic -- do not leak secret information!
# A store prefix should be considered as secret information.
# The snaps here which include one will insert it during builds by using a
# secret consumed by the relevant workflow.
name: <platform>
# The version is largely human readable, but should be meaningful.
# For instance, if the device boots with GRUB, have the version match the GRUB
# release used.
adopt-info|version: <grub|u-boot|some useful string>
# The summary should be short and simple
# The base of the snap should match the base of the Ubuntu Core system.
base: <base>
# build-base should only be used if creating a gadget for a devel release of Ubuntu Core.
type: gadget
# The grade should always be stable unless the gadget is using a devel-grade build-base.
grade: stable
confinement: strict
summary: An Ubuntu Core gadget for the <platform>
# Again: always include license information.
# Valid licenses: https://github.com/snapcore/snapd/blob/master/spdx/licenses.go
license: "CC-BY-SA-4.0 AND ..."
# This repository is upstream for this gadget. Optionally include your contact
# information.
issues: https://github.com/canonical/iot-field-kernel-snap/issues
website: https://github.com/canonical/iot-field-gadget-snap/tree/main
# The description should include boilerplate information and a description of
# any nuances with this gadget target platform.
# Always include license information.
description: |
  This snap provides the <bootloader> binaries for booting <platform>.

  Additionally it includes the gadget.yaml which defines our partition layout
  and any default configuration options for our Ubuntu Core device.

  ** Note that the license information of this snap is incomplete **
  Do your due diligence to ensure compliance with the licenses of the contents of this snap.

  The <text files you created> are licensed under CC-BY-SA-4.0

  You can find many licenses for the contents of this snap at the following locations:

  All provided: licenses/

# If you want the gadget.yaml to refer to assets provided by the kernel
# instead of this snap, use this key. See:
# https://snapcraft.io/docs/snapcraft-top-level-metadata
assumes: [kernel-assets]

# At a minimum the snap should build natively.
architectures:
  - build-on:  [<arch>]
    build-for: [<arch>]

# Any additional repositories required.
# For instance, if you are building on AMD64 for ARM64,
package-repositories:
  - type: apt
    components: [main]
    architectures: [<arch>]
    suites: [<release>, <release>-security, <release>-updates]
    key-id: F6ECB3762474EDA9D21B7022871920D1991BC93C
    url: http://ports.ubuntu.com/ubuntu-ports

# Please provide descriptive comments as necessary. Not everything needs to
# be documented or explained, but explaining why things are done can always help
# people who are learning!
parts:
  # The grub part is used to fetch a GRUB binary from the Ubuntu archive. This
  # package should provide us everything we need for a gadget which specifies
  # GRUB as a bootloader. Additionally, we can set the snap version information
  # from the GRUB package we use.
  grub:
    plugin: dump
    source: grub/
    stage-packages:
      - grub-efi-<arch>:${CRAFT_ARCH_BUILD_FOR}
    override-build: |
      craftctl default
      
      craftctl set version=$(find "${CRAFT_PART_BUILD}/../stage_packages/" \
                              -name grub-efi-${CRAFT_ARCH_BUILD_FOR}_*.deb \
                              -exec dpkg-deb -f {} Version \;)

      # grub.conf is required when bootloader is set to GRUB in the gadget.yaml
      # so that snapd knows how to prepare the boot environment during image build
      # and during general run mode
      touch "${CRAFT_PART_INSTALL}/grub.conf"

      # uEnv.txt is a file that our u-boot binary will search for and source on
      # boot. This file should launch our grubriscv64.efi binary and results in
      # a fully automated boot process.

    # We should ship license information
    organize:
      usr/share/doc/grub-efi-<arch>/:     licenses/grub-efi-<arch>/
      usr/share/doc/grub-efi-<arch>-bin/: licenses/grub-efi-<arch>-bin/
    stage:
      - grub.conf
      - grub<arch>.efi
      - licenses/

  # u-boot provides the bootloader binary for our target hardware. This binary
  # is of paramount importance when we declare u-boot as the bootloader in
  # our gadget.yaml. This is the binary the bootrom of our target hardware
  # should search for and execute after it performs its low-level device
  # initialization. With some platforms, we are exceptionally lucky and a u-boot
  # binary is provided for us (the RISC-V platforms supported on Ubuntu Classic
  # are such an example). In other cases (as with many ARM64 platforms), we
  # would have to build u-boot ourselves. The character of this part will change
  # dramatically based on this fact.
  u-boot:
    # TODO: define skeleton u-boot part

  # boot-sel provides a file snapd will look for just in case we choose u-boot
  # as our bootloader in the gadget.yaml. This file is populated by snapd
  # with important system information, like the name of the seed system and
  # the recovery mode we are booting with which tells snapd whether we are
  # installing Core, running Core, or trying to recover Core.
  boot-sel:
    after: [u-boot]
    plugin: nil
    build-packages:
      - u-boot-tools
    override-build: |
      mkenvimage -r -s 4096 \
        -o "${CRAFT_PART_INSTALL}/boot.sel" - < /dev/null

        touch "${CRAFT_PART_INSTALL}/uboot.conf"

  # boot-scr compiles our boot.scr.in file into an executable which u-boot can
  # execute at runtime. This script performs the necessary actions to boot an
  # Ubuntu Core system which declares u-boot as its bootloader.
  boot-scr:
    after: [u-boot]
    plugin: nil
    source: u-boot/
    build-packages:
      - u-boot-tools
    override-build: |
      mkimage -d boot.scr.in \
        "${CRAFT_PART_INSTALL}/boot.scr"

# Any necessary hooks. For instance, you can specify the API key here to be used
# by the prepare-device hook at runtime. If you don't know what an API key is,
# feel free to remove this.
# PLEASE do not check your API key into VCS :)
# The snaps here which include one will insert it during builds by using a
# secret consumed by the relevant workflow.
hooks:
  prepare-device:
    environment:
      MODEL_APIKEY: ""
